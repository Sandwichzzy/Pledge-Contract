{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interface/IBscPledgeOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBscPledgeOracle {\r\n    function getPrice(address token) external view returns (uint256);\r\n\r\n    function getPrices(uint256[] calldata assets) external view returns (uint256[] memory);\r\n    \r\n    function getUnderlyingPrice(uint256 cToken) external view returns (uint256);\r\n}"
    },
    "contracts/mock/MockERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title MockERC20\r\n * @dev 模拟的ERC20代币合约，用于测试\r\n * 任何人都可以铸造代币用于测试\r\n */\r\ncontract MockERC20 is ERC20 {\r\n    \r\n    uint8 private _decimals;\r\n    \r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals_,\r\n        uint256 initialSupply\r\n    ) ERC20(name, symbol) {\r\n        _decimals = decimals_;\r\n        if (initialSupply > 0) {\r\n            _mint(msg.sender, initialSupply);\r\n        }\r\n    }\r\n    \r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    // 任何人都可以铸造代币用于测试\r\n    function mint(address to, uint256 amount) public {\r\n        _mint(to, amount);\r\n    }\r\n    \r\n    // 铸造代币给调用者\r\n    function faucet(uint256 amount) public {\r\n        _mint(msg.sender, amount);\r\n    }\r\n} "
    },
    "contracts/mock/MockOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interface/IBscPledgeOracle.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract MockOracle is IBscPledgeOracle, Ownable {\r\n    mapping(address => uint256) internal priceMap;\r\n    \r\n    constructor() Ownable(msg.sender) {}\r\n    \r\n    function setPrice(address asset, uint256 price) public onlyOwner {\r\n        priceMap[asset] = price;\r\n    }\r\n\r\n    function getPrice(address asset) public view override returns (uint256) {\r\n       return priceMap[asset];\r\n    }\r\n\r\n    function getPrices(uint256[] calldata assets) public view override returns (uint256[] memory) {\r\n        uint256 len = assets.length;\r\n        uint256[] memory prices = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            prices[i] = getUnderlyingPrice(assets[i]);\r\n        }\r\n        return prices;\r\n    }\r\n\r\n    function getUnderlyingPrice(uint256 underlying) public view override returns (uint256) {\r\n        return priceMap[address(uint160(underlying))];\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockUniswap/UniswapV2Factory.sol": {
      "content": "/**\n * @title UniswapV2Factory - Uniswap V2 工厂合约和相关接口\n * @dev 这是Uniswap V2的完整实现，包含工厂合约、配对合约、ERC20实现和相关接口\n * @notice 在2020年5月4日提交到Etherscan进行验证\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title IUniswapV2Factory - Uniswap V2 工厂接口\n * @dev 定义了工厂合约的核心功能接口\n */\ninterface IUniswapV2Factory {\n\n\n    /**\n     * @dev 获取费用接收地址\n     * @return 接收交易费用的地址\n     */\n    function feeTo() external view returns (address);\n    \n    /**\n     * @dev 获取费用设置者地址\n     * @return 可以设置费用接收地址的管理员地址\n     */\n    function feeToSetter() external view returns (address);\n\n    /**\n     * @dev 获取两个代币的交易对地址\n     * @param tokenA 第一个代币地址\n     * @param tokenB 第二个代币地址\n     * @return pair 交易对合约地址，如果不存在则返回零地址\n     */\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    \n\n    function allPairs(uint) external view returns (address pair);\n    \n    /**\n     * @dev 获取所有交易对的数量\n     * @return 交易对总数\n     */\n    function allPairsLength() external view returns (uint);\n\n    /**\n     * @dev 为两个代币创建新的交易对\n     * @param tokenA 第一个代币地址\n     * @param tokenB 第二个代币地址\n     * @return pair 新创建的交易对地址\n     */\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n\n    function setFeeTo(address) external;\n    \n\n    function setFeeToSetter(address) external;\n}\n\n/**\n * @title IUniswapV2Pair - Uniswap V2 交易对接口\n * @dev 定义了交易对合约的所有功能，包括ERC20功能和AMM特定功能\n */\ninterface IUniswapV2Pair {\n    // ERC20 标准事件\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    // ERC20 基础功能\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    // EIP-712 签名相关\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    /**\n     * @dev 通过签名授权，实现无gas费授权（EIP-2612）\n     */\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    // AMM 特定事件\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    // AMM 核心功能\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    /**\n     * @dev 添加流动性，铸造LP代币\n     * @param to LP代币接收地址\n     * @return liquidity 铸造的LP代币数量\n     */\n    function mint(address to) external returns (uint liquidity);\n    \n    /**\n     * @dev 移除流动性，销毁LP代币\n     * @param to 代币接收地址\n     * @return amount0 代币0的返还数量\n     * @return amount1 代币1的返还数量\n     */\n    function burn(address to) external returns (uint amount0, uint amount1);\n    \n    /**\n     * @dev 执行代币交换\n     * @param amount0Out 代币0的输出数量\n     * @param amount1Out 代币1的输出数量\n     * @param to 代币接收地址\n     * @param data 回调数据\n     */\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    \n    /**\n     * @dev 强制余额匹配储备量\n     * @param to 多余代币的接收地址\n     */\n    function skim(address to) external;\n    \n    /**\n     * @dev 强制储备量匹配余额\n     */\n    function sync() external;\n\n\n    function initialize(address, address) external;\n}\n\n/**\n * @title IUniswapV2ERC20 - Uniswap V2 ERC20接口\n * @dev 扩展了标准ERC20接口，添加了permit功能\n */\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n\n/**\n * @title IERC20 - 标准ERC20接口\n * @dev 定义了ERC20代币的基础功能\n */\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n/**\n * @title IUniswapV2Callee - Uniswap V2 回调接口\n * @dev 用于闪电贷等高级功能的回调接口\n */\ninterface IUniswapV2Callee {\n    /**\n     * @dev Uniswap V2回调函数\n     * @param sender 调用者地址\n     * @param amount0 代币0数量\n     * @param amount1 代币1数量\n     * @param data 回调数据\n     */\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n\n/**\n * @title UniswapV2ERC20 - Uniswap V2 ERC20实现\n * @dev 实现了ERC20功能和permit签名授权功能\n */\ncontract UniswapV2ERC20 is IUniswapV2ERC20 {\n    using SafeMath for uint;\n\n    // 代币基本信息\n    string public constant name = 'Uniswap V2';\n    string public constant symbol = 'UNI-V2';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;                    // 总供应量\n    mapping(address => uint) public balanceOf;   // 账户余额\n    mapping(address => mapping(address => uint)) public allowance; // 授权额度\n\n    // EIP-712 签名相关\n    bytes32 public DOMAIN_SEPARATOR;\n    // permit函数的类型哈希\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;     // 防重放攻击的nonce\n\n    constructor() {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        // 初始化EIP-712域分隔符\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev 铸造代币\n     * @param to 接收地址\n     * @param value 铸造数量\n     */\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    /**\n     * @dev 销毁代币\n     * @param from 销毁地址\n     * @param value 销毁数量\n     */\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @dev 内部授权函数\n     * @param owner 授权者\n     * @param spender 被授权者\n     * @param value 授权数量\n     */\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev 内部转账函数\n     * @param from 发送方\n     * @param to 接收方\n     * @param value 转账数量\n     */\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev 授权函数\n     * @param spender 被授权地址\n     * @param value 授权数量\n     * @return 是否成功\n     */\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev 转账函数\n     * @param to 接收地址\n     * @param value 转账数量\n     * @return 是否成功\n     */\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev 授权转账函数\n     * @param from 发送方\n     * @param to 接收方\n     * @param value 转账数量\n     * @return 是否成功\n     */\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev 通过签名进行授权（EIP-2612）\n     * @param owner 代币拥有者\n     * @param spender 被授权者\n     * @param value 授权数量\n     * @param deadline 截止时间\n     * @param v 签名参数v\n     * @param r 签名参数r\n     * @param s 签名参数s\n     */\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n\n/**\n * @title UniswapV2Pair - Uniswap V2 交易对合约\n * @dev 实现了AMM核心逻辑的交易对合约\n */\ncontract UniswapV2Pair is UniswapV2ERC20 {\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3; // 最小流动性\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)'))); // transfer函数选择器\n\n    address public factory;    // 工厂合约地址\n    address public token0;     // 第一个代币地址\n    address public token1;     // 第二个代币地址\n\n    uint112 private reserve0;           // 代币0储备量（打包存储以节省gas）\n    uint112 private reserve1;           // 代币1储备量（打包存储以节省gas）\n    uint32  private blockTimestampLast; // 最后更新时间戳（打包存储以节省gas）\n\n    uint public price0CumulativeLast;   // 代币0累积价格\n    uint public price1CumulativeLast;   // 代币1累积价格\n    uint public kLast; // reserve0 * reserve1，用于计算费用\n\n    uint private unlocked = 1; // 重入锁\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /**\n     * @dev 获取储备量信息\n     * @return _reserve0 代币0储备量\n     * @return _reserve1 代币1储备量  \n     * @return _blockTimestampLast 最后更新时间戳\n     */\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    /**\n     * @dev 安全转账函数\n     * @param token 代币地址\n     * @param to 接收地址\n     * @param value 转账数量\n     */\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    /**\n     * @dev 初始化交易对（仅工厂调用一次）\n     * @param _token0 第一个代币地址\n     * @param _token1 第二个代币地址\n     */\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN');\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    /**\n     * @dev 更新储备量和价格累积器\n     * @param balance0 代币0当前余额\n     * @param balance1 代币1当前余额\n     * @param _reserve0 代币0之前储备量\n     * @param _reserve1 代币1之前储备量\n     */\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // 时间差（允许溢出）\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // 更新价格累积器，永不溢出，允许+溢出\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    /**\n     * @dev 如果启用费用，铸造等于sqrt(k)增长1/6的流动性\n     * @param _reserve0 代币0储备量\n     * @param _reserve1 代币1储备量\n     * @return feeOn 是否开启费用\n     */\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // 节省gas\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    /**\n     * @dev 添加流动性，铸造LP代币\n     * 这是一个低级函数，应该从执行重要安全检查的合约中调用\n     * @param to LP代币接收地址\n     * @return liquidity 铸造的LP代币数量\n     */\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // 节省gas\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // 必须在这里定义，因为totalSupply可能在_mintFee中更新\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // 永久锁定第一个MINIMUM_LIQUIDITY代币\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0和reserve1是最新的\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    /**\n     * @dev 移除流动性，销毁LP代币\n     * 这是一个低级函数，应该从执行重要安全检查的合约中调用\n     * @param to 代币接收地址\n     * @return amount0 代币0返还数量\n     * @return amount1 代币1返还数量\n     */\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // 节省gas\n        address _token0 = token0;                                // 节省gas\n        address _token1 = token1;                                // 节省gas\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // 必须在这里定义，因为totalSupply可能在_mintFee中更新\n        amount0 = liquidity.mul(balance0) / _totalSupply; // 使用余额确保按比例分配\n        amount1 = liquidity.mul(balance1) / _totalSupply; // 使用余额确保按比例分配\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0和reserve1是最新的\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    /**\n     * @dev 执行代币交换\n     * 这是一个低级函数，应该从执行重要安全检查的合约中调用\n     * @param amount0Out 代币0输出数量\n     * @param amount1Out 代币1输出数量\n     * @param to 代币接收地址\n     * @param data 回调数据\n     */\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // 节省gas\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // 作用域限制_token{0,1}，避免堆栈过深错误\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // 乐观转账代币\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // 乐观转账代币\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // 作用域限制reserve{0,1}Adjusted，避免堆栈过深错误\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    /**\n     * @dev 强制余额匹配储备量\n     * @param to 多余代币的接收地址\n     */\n    function skim(address to) external lock {\n        address _token0 = token0; // 节省gas\n        address _token1 = token1; // 节省gas\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    /**\n     * @dev 强制储备量匹配余额\n     */\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}\n\n/**\n * @title UniswapV2Factory - Uniswap V2 工厂合约实现\n * @dev 负责创建和管理所有的交易对合约\n */\ncontract UniswapV2Factory is IUniswapV2Factory {\n    address public feeTo;        // 费用接收地址\n    address public feeToSetter;  // 费用设置者地址\n    // 添加以避免每次元数据更改时都改变\n    bytes32 public initCodeHash; // 初始化代码哈希\n\n    mapping(address => mapping(address => address)) public getPair; // 代币对映射\n    address[] public allPairs;   // 所有交易对数组\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n        initCodeHash = keccak256(abi.encodePacked(type(UniswapV2Pair).creationCode));\n    }\n\n    /**\n     * @dev 获取所有交易对数量\n     * @return 交易对总数\n     */\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    /**\n     * @dev 为两个代币创建交易对\n     * @param tokenA 第一个代币地址\n     * @param tokenB 第二个代币地址\n     * @return pair 新创建的交易对地址\n     */\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // 单一检查就足够了\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IUniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // 反向映射\n        allPairs.push(pair);\n\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    /**\n     * @dev 设置费用接收地址\n     * @param _feeTo 新的费用接收地址\n     */\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeTo = _feeTo;\n    }\n\n    /**\n     * @dev 设置费用设置者地址\n     * @param _feeToSetter 新的费用设置者地址\n     */\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    }\n}\n\n/**\n * @title SafeMath - 安全数学运算库\n * @dev 提供溢出安全的数学运算，来源于DappHub (https://github.com/dapphub/ds-math)\n */\nlibrary SafeMath {\n    /**\n     * @dev 安全加法\n     * @param x 第一个操作数\n     * @param y 第二个操作数  \n     * @return z 加法结果\n     */\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    /**\n     * @dev 安全减法\n     * @param x 被减数\n     * @param y 减数\n     * @return z 减法结果\n     */\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    /**\n     * @dev 安全乘法\n     * @param x 第一个操作数\n     * @param y 第二个操作数\n     * @return z 乘法结果\n     */\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\n/**\n * @title Math - 数学运算库\n * @dev 提供各种数学运算函数\n */\nlibrary Math {\n    /**\n     * @dev 返回两个数中的较小值\n     * @param x 第一个数\n     * @param y 第二个数\n     * @return z 较小值\n     */\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    /**\n     * @dev 计算平方根（巴比伦方法）\n     * @notice 实现参考：https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n     * @param y 被开方数\n     * @return z 平方根\n     */\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n\n/**\n * @title UQ112x112 - 二进制定点数库\n * @dev 处理二进制定点数的库 (https://en.wikipedia.org/wiki/Q_(number_format))\n * @notice 范围: [0, 2**112 - 1]，精度: 1 / 2**112\n */\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    /**\n     * @dev 将uint112编码为UQ112x112\n     * @param y 输入的uint112数值\n     * @return z 编码后的UQ112x112数值\n     */\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // 永不溢出\n    }\n\n    /**\n     * @dev UQ112x112除以uint112，返回UQ112x112\n     * @param x 被除数（UQ112x112格式）\n     * @param y 除数（uint112格式）\n     * @return z 除法结果（UQ112x112格式）\n     */\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}"
    },
    "contracts/mock/MockUniswap/UniswapV2Router02.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-06-05\n*/\n// import \"hardhat/console.sol\";\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Factory {\n    function initCodeHash() external pure returns (bytes32);\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Router01 {\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\ncontract UniswapV2Router02 is IUniswapV2Router02 {\n    using SafeMath for uint;\n\n    address public immutable factory;\n    address public immutable WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                IUniswapV2Factory(factory).initCodeHash()\n            )))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n       (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n        // IERC20(token).transferFrom(from, to, value);\n   }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/mock/MockWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title MockWETH\r\n * @dev 模拟的WETH合约，用于测试\r\n */\r\ncontract MockWETH is ERC20 {\r\n    \r\n    event Deposit(address indexed dst, uint wad);\r\n    event Withdrawal(address indexed src, uint wad);\r\n    \r\n    constructor() ERC20(\"Wrapped Ether\", \"WETH\") {}\r\n    \r\n    // 存入ETH并铸造WETH\r\n    function deposit() public payable {\r\n        _mint(msg.sender, msg.value);\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // 销毁WETH并提取ETH\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf(msg.sender) >= wad, \"MockWETH: insufficient balance\");\r\n        _burn(msg.sender, wad);\r\n        payable(msg.sender).transfer(wad);\r\n        emit Withdrawal(msg.sender, wad);\r\n    }\r\n    \r\n    // 允许直接向合约发送ETH来铸造WETH\r\n    receive() external payable {\r\n        deposit();\r\n    }\r\n    \r\n    fallback() external payable {\r\n        deposit();\r\n    }\r\n} "
    },
    "contracts/multiSignature/multiSignatureClient.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title IMultiSignature - 多签名合约接口\r\n * @dev 定义了多签名合约需要实现的核心功能接口\r\n */\r\ninterface IMultiSignature {\r\n    /**\r\n     * @dev 获取有效签名索引\r\n     * @param msghash 消息哈希\r\n     * @param lastIndex 上次检查的索引\r\n     * @return uint256 返回有效的签名索引，如果没有达到阈值则返回0\r\n     */\r\n    function getValidSignature(bytes32 msghash, uint256 lastIndex) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title multiSignatureClient - 多签名客户端合约\r\n * @dev 为其他合约提供多签名验证功能的基础合约\r\n * @notice 任何需要多签名保护的合约都应该继承此合约，并使用validCall修饰符\r\n * \r\n * === 工作原理 ===\r\n * 1. 客户端合约继承此合约，获得多签名验证能力\r\n * 2. 重要函数使用validCall修饰符进行保护\r\n * 3. 调用时会自动检查对应的多签名申请是否已获得足够签名\r\n * 4. 只有通过多签名验证的调用才能执行\r\n */\r\ncontract multiSignatureClient {\r\n    uint256 public constant multiSignaturePosition = uint256(keccak256(\"org.multiSignature.storage\"));// 多签名合约地址的存储位置\r\n    uint256 private constant defaultIndex = 0;// 默认索引\r\n\r\n    /**\r\n     * @dev 构造函数\r\n     * @param multiSignature 多签名合约地址\r\n     * @notice 将多签名合约地址保存到固定的存储位置\r\n     */\r\n    constructor(address multiSignature) {\r\n        require(multiSignature != address(0), \"multiSignatureClient : Multiple signature contract address is zero!\");\r\n        saveValue(multiSignaturePosition, uint256(uint160(multiSignature)));\r\n    }\r\n\r\n    //从存储中读取多签名合约地址\r\n    function getMultiSignatureAddress() public view returns (address){\r\n        return address(uint160(getValue(multiSignaturePosition)));\r\n    }\r\n\r\n    /**\r\n     * @dev 多签名验证修饰符\r\n     * @notice 使用此修饰符的函数只有在多签名验证通过后才能执行\r\n     * @notice 这是整个多签名系统的核心验证机制\r\n     */\r\n    modifier validCall(){\r\n        checkMultiSignature();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev 检查多签名验证\r\n     * @notice 核心验证逻辑：\r\n     * 1. 生成消息哈希（调用者地址 + 当前合约地址）\r\n     * 2. 向多签名合约查询该哈希是否有足够的签名\r\n     * 3. 如果没有足够签名，交易将回滚\r\n     */\r\n    function checkMultiSignature() internal view {\r\n        uint256 value;\r\n        // 获取调用的以太币值（当前未使用，为未来扩展预留）\r\n        assembly {\r\n            value:=callvalue()\r\n        }\r\n        // 生成唯一的消息哈希：调用者地址 + 目标合约地址\r\n        // 这确保了每个(调用者, 目标合约)组合都有唯一的哈希\r\n        bytes32 msghash = keccak256(abi.encodePacked(msg.sender, address(this)));\r\n        // 获取多签名合约地址\r\n        address multiSign=getMultiSignatureAddress();\r\n\r\n        // 查询多签名合约，检查是否有足够的签名\r\n        // getValidSignature的实现逻辑（在multiSignature.sol中）：\r\n        // 1. 遍历该msgHash对应的所有申请\r\n        // 2. 检查每个申请的签名数量是否 >= threshold\r\n        // 3. 如果找到达到阈值的申请，返回其索引+1（确保非零）\r\n        // 4. 如果没有找到，返回0\r\n        uint256 newIndex=IMultiSignature(multiSign).getValidSignature(msghash,defaultIndex);\r\n        require(newIndex>defaultIndex,\"multiSignatureClient : This tx is not aprroved\");\r\n    }\r\n\r\n    /**\r\n     * @dev 保存值到指定存储位置\r\n     * @param position 存储位置（使用keccak256生成的唯一位置）\r\n     * @param value 要保存的值\r\n     * @notice 使用内联汇编直接操作存储，提高gas效率\r\n     */\r\n    function saveValue(uint256 position, uint256 value) internal {\r\n        assembly {\r\n            sstore(position, value)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev 从指定存储位置读取值\r\n     * @param position 存储位置（使用keccak256生成的唯一位置）\r\n     * @return value 读取的值\r\n     * @notice 使用内联汇编直接操作存储，提高gas效率\r\n     */\r\n    function getValue(uint256 position) internal view returns (uint256 value) {\r\n        assembly {\r\n            value := sload(position)\r\n        }\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/pledage/BscPledgeOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../multiSignature/multiSignatureClient.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\n\r\n/**\r\n * @title BscPledgeOracle - BSC质押协议价格预言机\r\n * @dev 混合价格预言机系统，支持Chainlink聚合器和手动价格设置\r\n * @notice 为Pledge系统提供可靠的价格数据，支持多种资产的价格查询\r\n * \r\n * === 核心设计特性 ===\r\n * 1. **双重价格源**：Chainlink聚合器（优先） + 手动设置价格（备用）\r\n * 2. **精度统一**：所有价格统一转换为18位小数精度\r\n * 3. **多签名控制**：价格设置和聚合器配置需要多签名验证\r\n * 4. **灵活配置**：支持动态添加/修改资产的价格源\r\n * \r\n * === 价格查询优先级 ===\r\n * 1. 如果配置了Chainlink聚合器 → 使用链上实时价格\r\n * 2. 如果没有聚合器 → 使用手动设置的价格\r\n * 3. 如果都没有 → 返回0（表示价格不可用）\r\n * \r\n * === 精度处理逻辑 ===\r\n * - Chainlink价格通常是8位小数（如BTC/USD $50000.12345678）\r\n * - 本系统统一使用18位小数（以太坊标准）\r\n * - 自动进行精度转换以确保计算准确性\r\n */\r\ncontract BscPledgeOracle is multiSignatureClient {\r\n\r\n    /**\r\n     * @dev 资产到Chainlink聚合器的映射\r\n     * key: 资产标识符（地址转uint256或自定义ID）\r\n     * value: Chainlink聚合器接口\r\n     */\r\n    mapping(uint256 => AggregatorV3Interface) internal assetsMap;\r\n\r\n    /**\r\n     * @dev 资产精度映射\r\n     * key: 资产标识符\r\n     * value: 该资产的小数位数（如USDC=6, WETH=18）\r\n     */\r\n    mapping(uint256 => uint256) internal decimalsMap;\r\n\r\n    /**\r\n     * @dev 手动设置的价格映射（备用价格源）\r\n     * key: 资产标识符\r\n     * value: 手动设置的价格（18位小数精度）\r\n     */\r\n    mapping(uint256 => uint256) internal pricesMap;\r\n\r\n    /**\r\n     * @dev 全局精度除数，用于Chainlink价格调整\r\n     * 默认为1，可通过setDecimals调整\r\n     */\r\n    uint256 internal decimals = 1;\r\n\r\n    constructor(address _multiSignature) multiSignatureClient(_multiSignature) {\r\n         // === BSC测试网聚合器地址示例 ===\r\n        // 这些地址在实际部署时可以启用，配置常用资产的Chainlink聚合器\r\n        \r\n        // BNB/USD聚合器\r\n        assetsMap[uint256(uint160(0x0000000000000000000000000000000000000000))] = AggregatorV3Interface(0x2514895c72f50D8bd4B4F9b1110F0D6bD2c97526);\r\n        \r\n        // DAI/USD聚合器  \r\n        assetsMap[uint256(uint160(0xf2bDB4ba16b7862A1bf0BE03CD5eE25147d7F096))] = AggregatorV3Interface(0xE4eE17114774713d2De0eC0f035d4F7665fc025D);\r\n        \r\n        // BTC/USD聚合器\r\n        assetsMap[uint256(uint160(0xF592aa48875a5FDE73Ba64B527477849C73787ad))] = AggregatorV3Interface(0x5741306c21795FdCBb9b265Ea0255F499DFe515C);\r\n        \r\n        // BUSD/USD聚合器\r\n        assetsMap[uint256(uint160(0xDc6dF65b2fA0322394a8af628Ad25Be7D7F413c2))] = AggregatorV3Interface(0x9331b55D9830EF609A2aBCfAc0FBCE050A52fdEa);\r\n\r\n        // === 对应的资产精度配置 ===\r\n        decimalsMap[uint256(uint160(0x0000000000000000000000000000000000000000))] = 18; // BNB\r\n        decimalsMap[uint256(uint160(0xf2bDB4ba16b7862A1bf0BE03CD5eE25147d7F096))] = 18; // DAI\r\n        decimalsMap[uint256(uint160(0xF592aa48875a5FDE73Ba64B527477849C73787ad))] = 18; // BTC\r\n        decimalsMap[uint256(uint160(0xDc6dF65b2fA0322394a8af628Ad25Be7D7F413c2))] = 18; // BUSD\r\n    }\r\n\r\n    /**\r\n     * @notice 设置全局精度参数\r\n     * @dev 用于调整Chainlink价格的精度转换\r\n     * @param newDecimals 新的精度除数\r\n     * \r\n     * === 使用场景 ===\r\n     * - Chainlink聚合器返回8位小数，设置为1e8进行标准化\r\n     * - 特殊情况下需要全局调整价格精度\r\n     */\r\n    function setDecimals(uint256 newDecimals) public validCall{\r\n        decimals=newDecimals;\r\n    }\r\n    /**\r\n     * @notice 批量设置资产价格\r\n     * @dev 手动设置多个资产的价格（备用价格源）\r\n     * @param assets 资产ID数组\r\n     * @param prices 对应的价格数组（18位小数精度）\r\n     */\r\n    function setPrices(uint256[] memory assets, uint256[] memory prices) external validCall{\r\n        require(assets.length==prices.length,\"input arrays length are not equal\");\r\n        uint256 len=assets.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            pricesMap[assets[i]]=prices[i];\r\n        }\r\n    }\r\n\r\n    // === 价格获取流程 ===\r\n    /**\r\n     * @notice 批量获取资产价格\r\n     * @dev 返回多个资产的当前价格\r\n     * @param assets 资产ID数组\r\n     * @return uint256[] 对应的价格数组（18位小数精度）\r\n     */\r\n    function getPrices(uint256[] memory assets) external view returns (uint256[] memory){\r\n        uint256 len=assets.length;\r\n        uint256[] memory prices=new uint256[](len);\r\n        for (uint256 i=0;i<len;i++){\r\n            prices[i]=getUnderlyingPrice(assets[i]);\r\n        }\r\n        return prices;\r\n    }\r\n    /**\r\n     * @notice 获取单个资产价格（通过地址）\r\n     * @dev 将资产地址转换为uint256后获取价格\r\n     * @param asset 资产合约地址\r\n     * @return uint256 资产价格（18位小数精度）\r\n     */\r\n    function getPrice(address asset) public view returns (uint256){\r\n        return getUnderlyingPrice(uint256(uint160(asset)));\r\n    }\r\n\r\n    /**\r\n     * @notice 获取单个资产价格（核心函数）\r\n     * @dev 实现双重价格源的价格获取逻辑\r\n     * @param underlying 资产标识符（地址转uint256或自定义ID）\r\n     * @return uint256 资产价格（18位小数精度）\r\n     */\r\n    function getUnderlyingPrice(uint256 underlying) public view returns (uint256){\r\n        //获取配置的chainlink聚合器\r\n        AggregatorV3Interface assetsPrice=assetsMap[underlying];\r\n        //优先使用chainlink聚合器价格\r\n        if (address(assetsPrice)!=address(0)){\r\n            // 调用Chainlink聚合器获取最新价格数据\r\n            (,int256 price,,,) = assetsPrice.latestRoundData();\r\n            // 根据资产精度进行转换\r\n            uint256 tokenDecimals=decimalsMap[underlying];\r\n            if (tokenDecimals<18){\r\n                // 例如：USDC(6位) → 18位\r\n                // price: $1.000000 (8位小数) → 需要补足到18位\r\n                return uint256(price)/decimals*(10**(18-tokenDecimals));\r\n            }else if (tokenDecimals>18){\r\n                // 理论情况：如果代币精度超过18位 → 需要降低精度\r\n                return uint256(price)/decimals/(10**(tokenDecimals-18));\r\n            }else{\r\n                // 如果精度正好是18位 → 直接除以精度\r\n                return uint256(price)/decimals;\r\n            }\r\n        }else{\r\n            // 如果没有聚合器 → 返回手动设置的价格\r\n            return pricesMap[underlying];\r\n        }\r\n    }\r\n\r\n        /**\r\n     * @notice 设置单个资产的手动价格（通过地址）\r\n     * @dev 为资产设置备用价格\r\n     * @param asset 资产合约地址\r\n     * @param price 价格值（18位小数精度）\r\n     */\r\n    function setPrice(address asset,uint256 price) public validCall {\r\n        pricesMap[uint256(uint160(asset))] = price;\r\n    }\r\n\r\n    /**\r\n     * @notice 设置单个资产的手动价格（通过ID）\r\n     * @dev 为资产设置备用价格\r\n     * @param underlying 资产标识符\r\n     * @param price 价格值（18位小数精度）\r\n     */\r\n    function setUnderlyingPrice(uint256 underlying,uint256 price) public validCall {\r\n        require(underlying>0 , \"underlying cannot be zero\");\r\n        pricesMap[underlying] = price;\r\n    }\r\n\r\n    /**\r\n     * @notice 设置资产的Chainlink聚合器（通过地址）\r\n     * @dev 为资产配置Chainlink价格源\r\n     * @param asset 资产合约地址\r\n     * @param aggregator Chainlink聚合器地址\r\n     * @param _decimals 资产的小数位数\r\n     */\r\n    function setAssetAggregator(address asset,address aggregator,uint256 _decimals) public validCall{\r\n        assetsMap[uint256(uint160(asset))]=AggregatorV3Interface(aggregator);\r\n        decimalsMap[uint256(uint160(asset))]=_decimals;\r\n    }\r\n\r\n    /**\r\n     * @notice 设置资产的Chainlink聚合器（通过ID）\r\n     * @dev 为资产配置Chainlink价格源\r\n     * @param underlying 资产标识符\r\n     * @param aggregator Chainlink聚合器地址\r\n     * @param _decimals 资产的小数位数\r\n     */\r\n    function setUnderlyingAggregator(uint256 underlying,address aggregator,uint256 _decimals) public validCall {\r\n        require(underlying>0 , \"underlying cannot be zero\");\r\n        assetsMap[underlying] = AggregatorV3Interface(aggregator);\r\n        decimalsMap[underlying] = _decimals;\r\n    }\r\n    /**\r\n     * @notice 获取资产的聚合器信息（通过地址）\r\n     * @dev 查询资产配置的Chainlink聚合器和精度\r\n     * @param asset 资产合约地址\r\n     * @return address 聚合器地址\r\n     * @return uint256 资产精度\r\n     */\r\n    function getAssetsAggregator(address asset) public view returns (address,uint256) {\r\n        return (address(assetsMap[uint256(uint160(asset))]),decimalsMap[uint256(uint160(asset))]);\r\n    }\r\n\r\n     /**\r\n       * @notice 获取资产的聚合器信息（通过ID）\r\n       * @dev 查询资产配置的Chainlink聚合器和精度\r\n       * @param underlying 资产标识符\r\n       * @return address 聚合器地址\r\n       * @return uint256 资产精度\r\n       */\r\n    function getUnderlyingAggregator(uint256 underlying) public view returns (address,uint256) {\r\n        return (address(assetsMap[underlying]),decimalsMap[underlying]);\r\n    }\r\n}"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}